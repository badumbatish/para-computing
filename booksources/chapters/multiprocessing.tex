% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `Parallel Programming in MPI and OpenMP'
%%%% by Victor Eijkhout, copyright 2012-2021
%%%%
%%%% multiprocessing.tex : python multiprocessing module
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstset{language=Python}

Python has a \indexterm{multiprocessing} toolbox.
This is a parallel processing library that relies on subprocesses,
rather than threads.

A process is an object that will execute a python function:
\pverbatimsnippet[code/multiprocessing/p/hello.py]{pyproccreate}

These processes can be started and,
using familiar terminology,
`join'ed:
\pverbatimsnippet[code/multiprocessing/p/hello.py]{pyprocstartjoin}

By making the start and join calls less regular than
in a loop like this,
arbitrarily complicated code can be produced.

Note the test on \n{__main__}:
the processes started read the current file in order to execute
the function specified.
Without this clause, the import would first execute more process start calls,
before getting to the function execution.

\Level 0 {Process}

Processes have a name that you can retrieve as
\lstinline+current_process().name+.
The default is \n{Process-5} and such,
but you can specify custom names:
\begin{lstlisting}
Process(name="Your name here")
\end{lstlisting}
The target function of a process can get hold of that process
with the  \lstinline+current_process+ function.

Of course you can also query \lstinline+os.getpid()+
but that does not offer any further possibilities.

\pverbatimsnippet[code/multiprocessing/p/hello.py]{pyprocpid}

\Level 0 {Shared data}

The best way to deal with shared data is to create
a \lstinline{Value} or \lstinline{Array} object,
which come equipped with a lock for safe updating.

\pverbatimsnippet{pypivalue}

For instance, one could stochastically calculate~$\pi$
by 
\begin{enumerate}
\item generating random points in~$[0,1)^2$, and
\item recording how many fall in the unit circle, after which
\item $\pi$ is $4\times$ the ratio between points in the circle
  and the total number of points.
\end{enumerate}

\pverbatimsnippet{pypicompute}

\begin{exercise}
  Do you see a way to improve the speed of this calculation?
\end{exercise}
